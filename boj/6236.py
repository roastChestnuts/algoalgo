# 문제
# 현우는 용돈을 효율적으로 활용하기 위해 계획을 짜기로 하였다. 
# 현우는 앞으로 N일 동안 자신이 사용할 금액을 계산하였고, 
# 돈을 펑펑 쓰지 않기 위해 정확히 M번만 통장에서 돈을 빼서 쓰기로 하였다. 
# 현우는 통장에서 K원을 인출하며, 통장에서 뺀 돈으로 하루를 보낼 수 있으면 그대로 사용하고, 
# 모자라게 되면 남은 금액은 통장에 집어넣고 다시 K원을 인출한다. 
# 다만 현우는 M이라는 숫자를 좋아하기 때문에, 
# 정확히 M번을 맞추기 위해서 남은 금액이 그날 사용할 금액보다 많더라도 
# 남은 금액은 통장에 집어넣고 다시 K원을 인출할 수 있다. 
# 현우는 돈을 아끼기 위해 인출 금액 K를 최소화하기로 하였다. 
# 현우가 필요한 최소 금액 K를 계산하는 프로그램을 작성하시오.

# 입력
# 1번째 줄에는 N과 M이 공백으로 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ N)

# 2번째 줄부터 총 N개의 줄에는 현우가 i번째 날에 이용할 금액이 주어진다. (1 ≤ 금액 ≤ 10,000)

# 출력
# 첫 번째 줄에 현우가 통장에서 인출해야 할 최소 금액 K를 출력한다.

# 예제 입력 1 
# 7 5
# 100
# 400
# 300
# 100
# 500
# 101
# 400

# 예제 출력 1 
# 500

# 돈을 인출하여 하루 소비치만큼 소비한 뒤에 남은 금액으로 다음날 소비가 가능하다면 소비
# 부족하다면 새로 금액을 인출하여 소비하는데 이 소비 횟수가 입력받은 M번만큼 소비가 가능한지를
# 체크하는게 핵심

# 만약 금액을 1원부터 10,000원까지 순차적으로 탐색하게 된다면 탐색횟수는 10억이 되므로
# 시간초과가 날 것.
# 그렇기 때문에 최저, 최고 금액을 두고서 횟수 m에 맞춰서 이분탐색을 통해 탐색횟수를 logN으로 줄일 것

#단조(monotonic) 성질을 가진 “가능 여부” 판정이 있을 때, 
# 그 판정이 바뀌는 임계값을 효율적으로 찾을 때 이분탐색을 사용

import sys

input = sys.stdin.readline

N, M = map(int, input().split())

moneys = list()
for _ in range(N):
    moneys.append(int(input()))

result = 0

start = max(moneys)
end = sum(moneys)

while start <= end:
    mid = (start + end) // 2
    K = mid
    count = 1
    for money in moneys:
        if money <= K:
            K -= money
        else : 
            count += 1
            K = mid - money    
    if count > M:
        start = mid + 1
    else: #count <= M
        end = mid - 1
        result = mid

print(result)   